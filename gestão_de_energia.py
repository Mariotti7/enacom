# -*- coding: utf-8 -*-
"""Gestão de Energia.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v5nMotaPg9Jfzarm7nwnQaY3WddyBb2l

## **>>> Fazer Upload dos Arquivos Localmente**
"""

from google.colab import files
import pandas as pd

# Upload dos arquivos
uploaded_1 = files.upload()
uploaded_2 = files.upload()

# Obter o nome do arquivo
nome_arquivo_1 = list(uploaded_1.keys())[0]
nome_arquivo_2 = list(uploaded_2.keys())[0]

# Ler o arquivo CSV usando o Pandas
dados_2019 = pd.read_csv(nome_arquivo_1, sep=';')
dados_2020 = pd.read_csv(nome_arquivo_2, sep=';')

"""## **>>> Verificações Básicas**


1.   Dados ausentes;
2.   Dados duplicados.


"""

# Verificar dados ausentes
dados_2019.isnull().sum()
dados_2020.isnull().sum()

# Tratar dados ausentes (se houver)
dados_2019 = dados_2019.dropna()
dados_2020 = dados_2020.dropna()

# Verificar duplicatas
dados_2019.duplicated().sum()
dados_2020.duplicated().sum()

# Remover duplicatas (se houver)
dados_2019 = dados_2019.drop_duplicates()
dados_2020 = dados_2020.drop_duplicates()

"""## **>>> Uma Rápida Visualização nos Dados de 2019**"""

print(dados_2019.head())

"""## **>>> Distribuição de Geração de Energia por Subsistema em 2019**"""

import matplotlib.pyplot as plt

# Agrupar dados por subsistema e calcular a média de geração de energia
dados_subsistema_2019 = dados_2019.groupby('nom_subsistema')['val_geracao'].mean()

# Gráfico de barras da média de geração de energia por subsistema
plt.figure(figsize=(10, 6))
dados_subsistema_2019.plot(kind='bar')
plt.xlabel('Subsistema - 2019')
plt.ylabel('Média de Geração de Energia')
plt.title('Distribuição de Geração de Energia por Subsistema em 2019')
plt.xticks(rotation=45)
plt.show()

"""## **>>> Distribuição de Geração de Energia por Estado em 2019**"""

# Agrupar dados por estado e calcular a média de geração de energia
dados_estado_2019 = dados_2019.groupby('nom_estado')['val_geracao'].mean()

# Gráfico de barras da média de geração de energia por estado
plt.figure(figsize=(15, 8))
dados_estado_2019.plot(kind='bar')
plt.xlabel('Estado')
plt.ylabel('Média de Geração de Energia')
plt.title('Distribuição de Geração de Energia por Estado em 2019')
plt.xticks(rotation=48)
plt.show()

"""## **>>> Distribuição de Geração de Energia por Tipo de Usina em 2019**"""

# Agrupar dados por tipo de usina e calcular a média de geração de energia
dados_tipo_usina_2019 = dados_2019.groupby('nom_tipousina')['val_geracao'].mean()

# Gráfico de barras da média de geração de energia por tipo de usina
plt.figure(figsize=(10, 6))
dados_tipo_usina_2019.plot(kind='bar')
plt.xlabel('Tipo de Usina')
plt.ylabel('Média de Geração de Energia')
plt.title('Distribuição de Geração de Energia por Tipo de Usina em 2019')
plt.xticks(rotation=45)
plt.show()

"""## **>>> Distribuição por Mês e Agrupado por Tipo de Usina em 2019**"""

import pandas as pd

dados_2019 = pd.read_csv(nome_arquivo_1, sep=';')

# Converter a coluna 'din_instante' para o tipo datetime
dados_2019['din_instante'] = pd.to_datetime(dados_2019['din_instante'])

# Extrair o mês da coluna 'din_instante' e criar uma nova coluna 'mes'
dados_2019['mes'] = dados_2019['din_instante'].dt.month

# Agrupar os dados por mês e 'nom_tipousina' e contar o número de ocorrências
grouped_data_2019 = dados_2019.groupby(['mes', 'nom_tipousina']).size().reset_index(name='count')

# Exibir o DataFrame resultante
print(grouped_data_2019)

"""## **>>> Uma Rápida Visualização nos Dados de 2020**"""

print(dados_2020.head())

"""## **>>> Distribuição de Geração de Energia por Subsistema em 2020**"""

import matplotlib.pyplot as plt

# Agrupar dados por subsistema e calcular a média de geração de energia
dados_subsistema_2020 = dados_2020.groupby('nom_subsistema')['val_geracao'].mean()

# Gráfico de barras da média de geração de energia por subsistema
plt.figure(figsize=(10, 6))
dados_subsistema_2020.plot(kind='bar')
plt.xlabel('Subsistema - 2019')
plt.ylabel('Média de Geração de Energia')
plt.title('Distribuição de Geração de Energia por Subsistema')
plt.xticks(rotation=45)
plt.show()

"""## **>>> Distribuição de Geração de Energia por Estado em 2020**"""

# Agrupar dados por estado e calcular a média de geração de energia
dados_estado_2020 = dados_2020.groupby('nom_estado')['val_geracao'].mean()

# Gráfico de barras da média de geração de energia por estado
plt.figure(figsize=(15, 8))
dados_estado_2020.plot(kind='bar')
plt.xlabel('Estado')
plt.ylabel('Média de Geração de Energia')
plt.title('Distribuição de Geração de Energia por Estado em 2020')
plt.xticks(rotation=48)
plt.show()

"""## **>>> Distribuição de Geração de Energia por Tipo de Usina em 2020**"""

# Agrupar dados por tipo de usina e calcular a média de geração de energia
dados_tipo_usina_2020 = dados_2020.groupby('nom_tipousina')['val_geracao'].mean()

# Gráfico de barras da média de geração de energia por tipo de usina
plt.figure(figsize=(10, 6))
dados_tipo_usina_2020.plot(kind='bar')
plt.xlabel('Tipo de Usina')
plt.ylabel('Média de Geração de Energia')
plt.title('Distribuição de Geração de Energia por Tipo de Usina em 2020')
plt.xticks(rotation=45)
plt.show()

"""## **>>> Distribuição por Mês e Agrupado por Tipo de Usina em 2020**"""

import pandas as pd

dados_2020 = pd.read_csv(nome_arquivo_2, sep=';')

# Converter a coluna 'din_instante' para o tipo datetime
dados_2020['din_instante'] = pd.to_datetime(dados_2020['din_instante'])

# Extrair o mês da coluna 'din_instante' e criar uma nova coluna 'mes'
dados_2020['mes'] = dados_2020['din_instante'].dt.month

# Agrupar os dados por mês e 'nom_tipousina' e contar o número de ocorrências
grouped_data_2020 = dados_2020.groupby(['mes', 'nom_tipousina']).size().reset_index(name='count')

# Exibir o DataFrame resultante
print(grouped_data_2020)

"""## **>>> Distribuição por Tipo de Usina em 2019**"""

# Agrupar por ano da coluna 'din_instante' e contar ocorrências de cada valor em 'nom_tipousina'
df_por_ano_2019 = dados_2019.groupby(dados_2019['din_instante'].dt.to_period('Y'))['nom_tipousina'].value_counts()

# Exibir o DataFrame resultante
print(df_por_ano_2019)

import matplotlib.pyplot as plt

# Agrupar por mês da coluna 'din_instante' e contar ocorrências de cada valor em 'nom_tipousina'
df_por_mes_2019 = dados_2019.groupby(dados_2019['din_instante'].dt.to_period('M'))['nom_tipousina'].value_counts()

# Reformatar o DataFrame resultante para facilitar a plotagem
df_por_mes_2019 = df_por_mes_2019.unstack().fillna(0)

# Plotar o gráfico de linhas
df_por_mes_2019.plot(kind='line', marker='o', figsize=(10, 6))
plt.title('Ocorrências de tipos de usina por mês')
plt.xlabel('Mês - 2019')
plt.ylabel('Número de ocorrências')
plt.legend(title='Tipo de Usina', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

# Agrupar por ano da coluna 'din_instante' e contar ocorrências de cada valor em 'nom_tipousina'
df_por_ano_2019 = dados_2019.groupby(dados_2019['din_instante'].dt.to_period('Y'))['nom_tipousina'].value_counts()

# Reformatar o DataFrame resultante para facilitar a plotagem
df_por_ano_2019 = df_por_ano_2019.unstack().fillna(0)

# Plotar o gráfico de linhas
df_por_ano_2019.plot(kind='line', marker='o', figsize=(10, 6))
plt.title('Ocorrências de tipos de usina por ano')
plt.xlabel('Ano - 2019')
plt.ylabel('Número de ocorrências')
plt.legend(title='Tipo de Usina')
plt.show()

"""## **>>> Distribuição por Geração de Energia em 2019**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

dados_2019 = pd.read_csv(nome_arquivo_1, sep=';')

# Resumo estatístico das variáveis numéricas
print(dados_2019.describe())

# Visualização da distribuição da variável alvo 'val_geracao'
plt.figure(figsize=(10, 6))
sns.histplot(dados_2019['val_geracao'], bins=30, kde=True, color='blue')
plt.title('Distribuição da Geração de Energia')
plt.xlabel('Geração de Energia')
plt.ylabel('Frequência')
plt.show()

"""## **>>> Treinando o Modelo de Regressão para Geração de Energia - 2019**"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

dados_2019 = pd.read_csv(nome_arquivo_1,sep=';')

# Remover linhas com valores ausentes na variável alvo
dados_2019.dropna(subset=['val_geracao'], inplace=True)

# Pré-processamento de dados
X = dados_2019.drop('val_geracao', axis=1)  # Features
y = dados_2019['val_geracao']  # Alvo

# Separar as colunas categóricas e numéricas
colunas_numericas_2019 = X.select_dtypes(include=['float64', 'int64']).columns
colunas_categoricas_2019 = X.select_dtypes(include=['object']).columns

# Construir um transformador para aplicar one-hot encoding nas variáveis categóricas
transformer_2019 = ColumnTransformer(
    transformers=[
        ('onehot', OneHotEncoder(), colunas_categoricas_2019)
    ],
    remainder='passthrough'
)

# Criar um pipeline com o transformador e o modelo de regressão linear
pipeline_2019 = Pipeline([
    ('preprocessor', transformer_2019),
    ('model', LinearRegression())
])

# Dividir os dados em conjunto de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Treinar o modelo
pipeline_2019.fit(X_train, y_train)

# Fazer previsões nos dados de teste
y_pred = pipeline_2019.predict(X_test)

# Calcular métricas de avaliação
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = mean_squared_error(y_test, y_pred, squared=False)  # Calcula o RMSE a partir do MSE
r2 = r2_score(y_test, y_pred)

# Exibir as métricas
print('-- Métricas de Avaliação -- ')
print("Mean Absolute Error (MAE):", mae)
print("Mean Squared Error (MSE):", mse)
print("Root Mean Squared Error (RMSE):", rmse)
print("R-squared (R²):", r2)

"""## **>>> Visualizar os Coeficientes do Modelo Treinado - 2019**"""

# Acessar os coeficientes do modelo treinado
coeficientes_2019 = pipeline_2019.named_steps['model'].coef_

# Colunas para o DataFrame
colunas_2019 = transformer_2019.transformers_[0][1].get_feature_names_out(colunas_categoricas_2019).tolist() + colunas_numericas_2019.tolist()

# Criar DataFrame com coeficientes e colunas correspondentes
df_coeficientes_2019 = pd.DataFrame({'Variável': colunas_2019, 'Coeficiente': coeficientes_2019})

# Ordenar os coeficientes por magnitude
df_coeficientes_2019 = df_coeficientes_2019.reindex(df_coeficientes_2019['Coeficiente'].abs().sort_values(ascending=False).index)

# Exibir os coeficientes
print(df_coeficientes_2019)

"""## **>>> Distribuição por Tipo de Usina em 2020**"""

# Agrupar por ano da coluna 'din_instante' e contar ocorrências de cada valor em 'nom_tipousina'
df_por_ano_2020 = dados_2020.groupby(dados_2020['din_instante'].dt.to_period('Y'))['nom_tipousina'].value_counts()

# Exibir o DataFrame resultante
print(df_por_ano_2020)

import matplotlib.pyplot as plt

# Agrupar por mês da coluna 'din_instante' e contar ocorrências de cada valor em 'nom_tipousina'
df_por_mes_2020 = dados_2020.groupby(dados_2020['din_instante'].dt.to_period('M'))['nom_tipousina'].value_counts()

# Reformatar o DataFrame resultante para facilitar a plotagem
df_por_mes_2020 = df_por_mes_2020.unstack().fillna(0)

# Plotar o gráfico de linhas
df_por_mes_2020.plot(kind='line', marker='o', figsize=(10, 6))
plt.title('Ocorrências de tipos de usina por mês')
plt.xlabel('Mês - 2020')
plt.ylabel('Número de ocorrências')
plt.legend(title='Tipo de Usina')
plt.show()

# Agrupar por ano da coluna 'din_instante' e contar ocorrências de cada valor em 'nom_tipousina'
df_por_ano_2020 = dados_2020.groupby(dados_2020['din_instante'].dt.to_period('Y'))['nom_tipousina'].value_counts()

# Reformatar o DataFrame resultante para facilitar a plotagem
df_por_ano_2020 = df_por_ano_2020.unstack().fillna(0)

# Plotar o gráfico de linhas
df_por_ano_2020.plot(kind='line', marker='o', figsize=(10, 6))
plt.title('Ocorrências de tipos de usina por ano')
plt.xlabel('Ano - 2020')
plt.ylabel('Número de ocorrências')
plt.legend(title='Tipo de Usina')
plt.show()

"""## **>>> Distribuição por Geração de Energia em 2020**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

dados_2020 = pd.read_csv(nome_arquivo_2, sep=';')

# Resumo estatístico das variáveis numéricas
print(dados_2020.describe())

# Visualização da distribuição da variável alvo 'val_geracao'
plt.figure(figsize=(10, 6))
sns.histplot(dados_2020['val_geracao'], bins=30, kde=True, color='blue')
plt.title('Distribuição da Geração de Energia')
plt.xlabel('Geração de Energia')
plt.ylabel('Frequência')
plt.show()

"""## **>>> Treinando o Modelo de Regressão para Geração de Energia - 2020**"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

dados_2020 = pd.read_csv(nome_arquivo_2,sep=';')

# Remover linhas com valores ausentes na variável alvo
dados_2020.dropna(subset=['val_geracao'], inplace=True)

# Pré-processamento de dados
X = dados_2020.drop('val_geracao', axis=1)  # Features
y = dados_2020['val_geracao']  # Alvo

# Separar as colunas categóricas e numéricas
colunas_numericas_2020 = X.select_dtypes(include=['float64', 'int64']).columns
colunas_categoricas_2020 = X.select_dtypes(include=['object']).columns

# Construir um transformador para aplicar one-hot encoding nas variáveis categóricas
transformer_2020 = ColumnTransformer(
    transformers=[
        ('onehot', OneHotEncoder(), colunas_categoricas_2020)
    ],
    remainder='passthrough'
)

# Criar um pipeline com o transformador e o modelo de regressão linear
pipeline_2020 = Pipeline([
    ('preprocessor', transformer_2020),
    ('model', LinearRegression())
])

# Dividir os dados em conjunto de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Treinar o modelo
pipeline_2020.fit(X_train, y_train)

# Fazer previsões nos dados de teste
y_pred = pipeline_2020.predict(X_test)

# Calcular métricas de avaliação
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = mean_squared_error(y_test, y_pred, squared=False)  # Calcula o RMSE a partir do MSE
r2 = r2_score(y_test, y_pred)

# Exibir as métricas
print('-- Métricas de Avaliação -- ')
print("Mean Absolute Error (MAE):", mae)
print("Mean Squared Error (MSE):", mse)
print("Root Mean Squared Error (RMSE):", rmse)
print("R-squared (R²):", r2)

"""## **>>> Visualizar os Coeficientes do Modelo Treinado - 2020**"""

# Acessar os coeficientes do modelo treinado
coeficientes_2020 = pipeline_2020.named_steps['model'].coef_

# Colunas para o DataFrame
colunas_2020 = transformer_2020.transformers_[0][1].get_feature_names_out(colunas_categoricas_2019).tolist() + colunas_numericas_2019.tolist()

# Criar DataFrame com coeficientes e colunas correspondentes
df_coeficientes_2020 = pd.DataFrame({'Variável': colunas_2020, 'Coeficiente': coeficientes_2020})

# Ordenar os coeficientes por magnitude
df_coeficientes_2020 = df_coeficientes_2020.reindex(df_coeficientes_2020['Coeficiente'].abs().sort_values(ascending=False).index)

# Exibir os coeficientes
print(df_coeficientes_2020)